// ——————————————————————— basic_test.s ———————————————————————
expected_reg[0]  = 32'h00000000;
expected_reg[1]  = 32'h00000007;    // $1 = 7
expected_reg[2]  = 32'h00000015;    // $2 final = 21 (updated later)
expected_reg[3]  = 32'hFFFFFFFB;    // -5
expected_reg[4]  = 32'h00000000;
expected_reg[5]  = 32'h00000064;    // 100
expected_reg[6]  = 32'h00000014;    // 20
expected_reg[7]  = 32'h00000014;    // overwritten by lw -> 20
expected_reg[8]  = 32'h00000015;    // overwritten by lw -> 21
expected_reg[9]  = 32'h0000000F;    // 15
expected_reg[10] = 32'h00000004;
expected_reg[11] = 32'hFFFFFFFC;
expected_reg[12] = 32'h00000001;
expected_reg[13] = 32'h00000010;
expected_reg[14] = 32'hFFFFFFFB;    // overwritten by lw from MEM[105] (r3 = -5)
expected_reg[15] = 32'hFFFFFFFC;
expected_reg[16] = 32'h0000000B;    // 11
expected_reg[17] = 32'h000003E7;    // 999
expected_reg[18] = 32'h000003E7;    // 999 (loaded)
expected_reg[19] = 32'h000003FB;    // 1019
expected_reg[20] = 32'h40000000;    // 1 << 30
expected_reg[21] = 32'h00000014;    // loaded later from MEM[101] -> 20
expected_reg[22] = 32'h0000000F;    // loaded later from MEM[102] -> 15
expected_reg[23] = 32'h00000000;    // not written due to overflow exception
expected_reg[24] = 32'h0000FFFF;    // 65535
expected_reg[25] = 32'hFFFF0000;    // -65536
expected_reg[26] = 32'h00000007;    // 7 (from MEM[100])
expected_reg[27] = 32'h00000007;    // 7 (from MEM[99])
expected_reg[28] = 32'h7FFFFFFF;    // INT_MAX (set before overflow)
expected_reg[29] = 32'h80000000;    // 1 << 31
expected_reg[30] = 32'h00000002;    // rstatus from addi overflow (should be 2)
expected_reg[31] = 32'h7FFFFFFF;    // INT_MAX (set earlier)

// Memory expectations (word addresses)
expected_mem_arr[99]  = 32'h00000007;    // MEM[$5 - 1]
expected_mem_arr[100] = 32'h00000007;    // MEM[$5 + 0]
expected_mem_arr[101] = 32'h00000014;    // MEM[$5 + 1]
expected_mem_arr[102] = 32'h0000000F;    // MEM[$5 + 2]
expected_mem_arr[103] = 32'h00000014;    // MEM[$5 + 3]
expected_mem_arr[105] = 32'hFFFFFFFB;    // MEM[$5 + 5] = r3 (-5)
expected_mem_arr[107] = 32'h00000015;    // MEM[$5 + 7] = r2 (21)
expected_mem_arr[111] = 32'h000003E7;    // MEM[$5 + 11] = 999


// ——————————————————————— branch_complete.s ———————————————————————
// expected register values
expected_reg[1]  = 32'h00000001;    // $1 = 1
expected_reg[2]  = 32'h00000002;    // $2 = 2

expected_reg[4]  = 32'h00000004;    // $4 = 4
expected_reg[5]  = 32'hFFFFFFFF;    // $5 = -1

expected_reg[7]  = 32'h00000007;    // $7 = 7

expected_reg[8]  = 32'h00000001;    // $8 = 1
expected_reg[9]  = 32'h00000001;    // $9 = 1
expected_reg[10]  = 32'h00000001;    // $10 = 1


expected_reg[11]  = 32'h00000002;    // $11 = 2
expected_reg[12]  = 32'h00000001;    // $12 = 1
expected_reg[13]  = 32'h00000001;    // $13 = 1


// ——————————————————————— j_isolated.s ———————————————————————
// expected register values
expected_reg[1]  = 32'h00000000;    // $1 = 0
expected_reg[2]  = 32'h00000001;    // $2 = 1


// branch_jump.s expected register values
expected_reg[0]  = 32'h00000000;
expected_reg[1]  = 32'h00000005;    // $1 = 5
expected_reg[2]  = 32'h00000005;    // $2 = 5
expected_reg[3]  = 32'h00000063;    // $3 = 99
expected_reg[4]  = 32'h00000002;    // $4 = 2
expected_reg[5]  = 32'h00000003;    // $5 = 3
expected_reg[6]  = 32'h00000007;    // $6 = 7
expected_reg[7]  = 32'h0000000A;    // $7 = 10
expected_reg[8]  = 32'h0000000B;    // $8 = 11 (result from subroutine)
expected_reg[9]  = 32'h0000000B;    // $9 = 11 (copied from $8)
expected_reg[10]  = 32'h00000001;    // $10 = 1
expected_reg[11]  = 32'h00000001;    // $11 = 1
expected_reg[12]  = 32'h0000001;    // $12 = 1
expected_reg[13]  = 32'h00000001;    // $13 = 1
expected_reg[30] = 32'h00000000;    // $rstatus = 0 (from setx 0)
expected_reg[31] = 32'h00000013;    // $ra = 19 (PC+1 from jal at PC=18)


// complete_test.s
expected_reg[0]  = 32'h00000000; // Always 0
expected_reg[1]  = 32'h00000002; // Final value 2
expected_reg[2]  = 32'h00000005; // Final value 5
expected_reg[3]  = 32'h000000FF; // 255
expected_reg[4]  = 32'h80000000; // Max Negative
expected_reg[5]  = 32'h7FFFFFFF; // Max Positive
expected_reg[6]  = 32'h00000064; // 100 (Base Address)
expected_reg[7]  = 32'h00000000;
expected_reg[8]  = 32'h00000000;
expected_reg[9]  = 32'h00000000;
expected_reg[10] = 32'h000007D0; // 2000 (BEX Taken Path)
expected_reg[11] = 32'h00000BB8; // 3000 (BEX Not Taken Path)
expected_reg[12] = 32'h00000000;
expected_reg[13] = 32'h00000000;
expected_reg[14] = 32'h00000000;
expected_reg[15] = 32'h00000084; // 132 (Subroutine result)
expected_reg[16] = 32'h0000000F; // 15 (10 + 5)
expected_reg[17] = 32'h00000005; // 5 (10 - 5)
expected_reg[18] = 32'h00000000; // 0 (10 & 5)
expected_reg[19] = 32'h000000FF; // 255 (10 | 255)
expected_reg[20] = 32'h00000028; // 40 (5 << 3)
expected_reg[21] = 32'hC0000000; // SRA of 0x80000000 by 1
expected_reg[22] = 32'h80000004; // Overflow Add result
expected_reg[23] = 32'h0000006E; // 110 (10 + 100)
expected_reg[24] = 32'h0000000A; // 10 (Loaded from Mem[100])
expected_reg[25] = 32'h00000000; // 0 (Loaded from uninitialized Mem[104])
expected_reg[26] = 32'h80000004; // Overflow Addi result
expected_reg[27] = 32'h7FFFFFFB; // Overflow Sub result (Wraparound)
expected_reg[28] = 32'h00000064; // 100 (BNE Not Taken)
expected_reg[29] = 32'h000000C8; // 200 (BLT Taken)
expected_reg[30] = 32'h00000000; // Cleared by setx 0
expected_reg[31] = 32'h00000032; // 50 (Return Address from JAL = PC+1)

expected_mem_arr[100] = 32'h0000000a;	// sw $1, 0($6) ; $1 = 10 , $6 = 100


// extreme_test.s
expected_reg[0]  = 32'h00000000; // Always 0
expected_reg[1]  = 32'h0000000B; // 11 (Block K: Marker that bex jumped)
expected_reg[2]  = 32'h00000002; // 2 (Block K: Inside CALLER_FUNC)
expected_reg[3]  = 32'hFFFFFFFB; // -5 (Block K: Inside CALLER_FUNC)
expected_reg[4]  = 32'h00000004; // 4 (Block K: Inside CALLER_FUNC)
expected_reg[5]  = 32'h00000000; // 0 (Block K: Reset after function return)
expected_reg[6]  = 32'h00000006; // 6 (Block K: AFTER_STUB marker)
expected_reg[7]  = 32'h0000004D; // 77 (Block K: Inside CALLER_FUNC)
expected_reg[8]  = 32'h00000008; // 8 (Block K: J_TARGET marker)
expected_reg[9]  = 32'h00000063; // 99 (Block K: After failed bex)
expected_reg[10] = 32'h00000004; // 4 (Block C)
expected_reg[11] = 32'hFFFFFFFC; // -4 (Block C)
expected_reg[12] = 32'h00000001; // 1 (Block A)
expected_reg[13] = 32'h00000010; // 16 (Block D)
expected_reg[14] = 32'hFFFFFFFB; // -5 (Block E/Permutations: Overwrites -16)
expected_reg[15] = 32'hFFFFFFFC; // -4 (Block D)
expected_reg[16] = 32'h0000000B; // 11 (Block I)
expected_reg[17] = 32'h000003E7; // 999 (Block I)
expected_reg[18] = 32'h000003E7; // 999 (Block I)
expected_reg[19] = 32'h000003FB; // 1019 (Block I)
expected_reg[20] = 32'h40000000; // 1 << 30 (Block F)
expected_reg[21] = 32'h00000014; // 20 (LW Permutations: Overwrites 0x80000000)
expected_reg[22] = 32'h0000000F; // 15 (LW Permutations: Loads $9 value)
expected_reg[23] = 32'h00000000;
expected_reg[24] = 32'h0000FFFF; // 65535 (ADDI Edge)
expected_reg[25] = 32'hFFFF0000; // -65536 (ADDI Edge: 17-bit min)
expected_reg[26] = 32'h00000007; // 7 (ADDI Address calc)
expected_reg[27] = 32'h00000007; // 7 (ADDI Address calc)
expected_reg[28] = 32'h00000004; // 4 (Block J: BLT Taken marker, overwrites overflow)
expected_reg[29] = 32'h80000000; // Min Neg (Block H: Skipped overwrite in Block J)
expected_reg[30] = 32'h00000000; // 0 (Block K: Cleared by setx 0)
expected_reg[31] = 32'h00000044; // 68 (Return Address from JAL at PC 67) , jr : PC = PC + 1

// Base Address $5 = 100
expected_mem_arr[99]  = 32'h00000007; // 7
expected_mem_arr[100] = 32'h00000007; // 7
expected_mem_arr[101] = 32'h00000014; // 20
expected_mem_arr[102] = 32'h0000000F; // 15
expected_mem_arr[103] = 32'h00000014; // 20
expected_mem_arr[105] = 32'hFFFFFFFB; // -5
expected_mem_arr[107] = 32'h00000015; // 21
expected_mem_arr[111] = 32'h000003E7; // 999